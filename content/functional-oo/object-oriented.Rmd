---
title: Object-oriented programming
weight: 2
output:
  blogdown::html_page:
    toc: true
---

Under construction.

## Outlook

The purpose of this chapter is introducing you to object-oriented programming (OOP) in R. Base R offers three different models for OOP:

- [S3](http://search.r-project.org/library/base/html/UseMethod.html),
- [S4](http://search.r-project.org/library/methods/html/Introduction.html), and
- [Reference Classes](http://search.r-project.org/library/methods/html/refClass.html).

Further, some R packages on CRAN are available that provide additional models (e. g., R6, R.oo or proto).

Here we focus on an introduction of the models available in base R and a discussion of their advantages and disadvantages. For a more in depth introduction to the mechanics of OOP in R you may want to read in Part III of [Advanced R](https://adv-r.hadley.nz/oo.html).

## Terminology

An important reason to use OOP is that it allows for [**polymorphism**](https://en.wikipedia.org/wiki/Polymorphism_(computer_science)), which greatly fascilitates reusability and extendability. Polymorphism means that a single symbol may refer to different types. In particular, this approach allows for the separation of the interface of a piece of software and its implementation. A software developer who wants to reuse some already existing software thus only needs to know the interface against which he is programming and what the expected behaviour is. The details of the implementation on the other hand are not required to be know. One specific implementation of an interface could thus even be exchanged for another one and the two implementations may (internally) works quite different without affecting the validity of the software that makes use of them.

In OOP the implementation is **encapsulated** in an **object**; i. e., its data and functionality are conceptionally at the same place, but separate from the rest. Every object is typed and the details of the type are specified in its **class** definition. The state (this can include data) of an object is specified via its **fields** and the behaviour is specified by its **methods**. Many OOP model (but not all) allow for [**inheritance**](https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)) when defining new classes. If one class (the derived class is usually referred to as the child) inherits from another class (the base class is usually referred to as the parent) then the child class will have all the fields and methods of the parent class available and the fields and methods from the definition are added to those. The resulting hierarchical structure is often displayed graphically in form of a [class diagram](https://en.wikipedia.org/wiki/Class_diagram) which are part of the [Unified Modelling Language](https://en.wikipedia.org/wiki/Unified_Modeling_Language) (UML). The use of UML can be very helpful when designing software systems using OOP.

With classes and their relationships to each other laid out in a tactical way (e. g., via inheritance and how they interact or are associated to each other) software systems become more easily maintainable and it is often possible to extend functionality without changes to the already existing code. Reusable solutions and best practices in OOP are documented in a formalised fashion as [**design patterns**](https://en.wikipedia.org/wiki/Software_design_pattern).

The different OOP models in R vary in the degree of encapsulation that they provide. S3 is probably the least rigorous of the models available in base R. In [Advanced R](https://adv-r.hadley.nz/oo.html) it is described as **functional OOP**, because of the mechanism in which a function call of the form `generic(object, additional_args)` is dispatached. Here, a **method dispatach** refers to finding the right code to evaluate given the type of `object`. S4 enforces more disciplined programming by requiring formal definitions that S3 does not require. The upside to this extra work is that a greater degree of integrity can be guaranteed. Reference Classes implement properly encapsulated object-oriented paradigm. In particular, they are **mutable**, meaning that they can be modified in place avoiding R's usual copy-on-modify mechanism.

## S3

The easiest and most informal system for OOP in R is called S3 (named after version 3 of the S programming language into which it was introduced). For S3 there is no formal class definition. While, on the one hand, this makes using the system very flexible, on the other hand, it also means that there are usually no build-in integrity checks. Programming with S3 is largely based on conventions. We outline how to use S3 in the rest of this section.

An S3 object is an object of a base type with the attribute `class` set to the class name. If you feel that you need to revise what base types and attributes are in R we refer you to Sections [3.3](https://adv-r.hadley.nz/vectors-chap.html#attributes) and [12](https://adv-r.hadley.nz/vectors-chap.html#attributes) in [Advanced R](https://adv-r.hadley.nz/oo.html). The functions `class()` and `unclass()` provide a convenient way to set the attribute to a class name or strip it off the object again.

It is good practice to have a **constructor** function that a user can call to initialise all relevant elements of the object and then return the object afterwards. In [Advanced R](https://adv-r.hadley.nz/oo.html) it is recommended to have only the essential elements in the constructor and validate the arguments in a separate function (the **validator**). Further, in [Advanced R](https://adv-r.hadley.nz/oo.html) it is recommended to have a **helper** function that is intended for end users. This function is meant to make the constructor more user-friendly, for example, by anticipating common mistakes and correcting them on the fly.

The following code block illustrates how to construct a vector `y` with $n$ responses, an $n \times p$ design matrix `x` and the ordinary least squares estimate b into an S3 object.

```{r}
# set seed for reproducibility
set.seed(123)

# define sample size, coefficients, regressor and response
n  <- 50
b0 <- matrix(c(2, -1), ncol = 1)
x  <- rnorm(n)
y  <- b0[1] + b0[2] * x + rnorm(n)

# Constructor for `simple_lin_regression`.
#
# This function computes the ordinary least squares estimate
# for the simple linear regression E[y|x] = b0 + b1 * x.
#
# Params: y - a vector with n elements; observed responses
#         x - a vector with n elements; observed regressors
#
# Returns: an S3 object of type simple_lin_regression
#
simple_lin_regression <- function(y, x) {
  # define design matrix
  D  <- matrix(c(rep(1, n), x), ncol = 2)
  
  # compute the OLS estimate
  b  <- solve(t(D) %*% D) %*% t(D) %*% y 
  
  # the object will encapsulate y, X and b
  slr <- list(response = y, regressor = x, estimate = b)
  
  # the object `slr` is declared to be an S3 object of
  # class "simple_lin_regression", by
  class(slr) <- "simple_lin_regression"
  
  return(slr)
}

sl1 <- simple_lin_regression(y, x)
```

One reason for organising the data and estimates in this way is that we can now implement special versions of generic methods (e. g., `print` and `plot`) that will be capable of working with this class of objects. Methods for S3 objects are defined by the following naming convenction `[method_name].[class_name]()`. For example, we can implement `print` and `plot` for our class `simple_lin_regression` by the following code

```{r}
print.simple_lin_regression <- function(x, ...) {
  cat("head(x) =", head(x$regressor), "\n")
  cat("head(y) =", head(x$response), "\n\n")
  cat("Estimated regression: E[y|x] = b0 + b1 * x\n")
  cat("b0 = ", x$estimate[1], " and b1 = ", x$estimate[2], ".\n", sep = "")
}

plot.simple_lin_regression <- function(x, y = NULL, ...) {
  plot(x = x$regressor, y = x$response,
       xlab = expression(X), ylab = expression(Y))
  abline(a = x$estimate[1], b = x$estimate[2])
}
```

Now we call them on the object `sl` that we previously created.
```{r}
print(sl1)
plot(sl1)
```

Note that to implement a method for an S3 class, a generic function of the same name needs to exist. You can, for example, see the definition of the generic function `plot` by
```{r}
plot
```

Note that the generic function `plot` has two compulsory arguments `x` and `y` and optional arguments indicated by `...`. The generic functions body is always a call of the function `UseMethod("[name_of_generic_function]")`.

When defining a method that implements a generic function for an S3 object it must have the same arguments as the generic function.

It is possible to introduce new generic functions. For example, we want to do a residual analysis. No generic `residual_analysis` does yet exist and we therefore define it ourselves:
```{r}
residual_analysis <- function(x) {
  UseMethod("residual_analysis")
}
```

Next we implement it for our `simple_lin_regression` class:

```{r}
residual_analysis.simple_lin_regression <- function(x) {
  predictions <- x$estimate[1] + x$estimate[2] * x$regressor
  plot(x = predictions, y = x$response - predictions,
       xlab = expression(hat(Y)), ylab = expression(Y - hat(Y)))
}
```

Now, we can apply the residual analysis function to our object:
```{r}
residual_analysis(sl1)
```

S3 classes allow for inheritance by setting the `class` attribute to a vector of class names.

For an example let us create an object of class `ordered` and check its class:
```{r}
ord_factor <- ordered(c("a", "b", "a"))
class(ord_factor)
```

You can see that the first element of the class attribute is `ordered` and the second is `factor`. This means that the class `ordered` extends the class factor. If a generic is implemented for the class ordered it will be called, but if it is not (yet) implemented the dispatch mechanism will try to find an implementation of the generic for class `factor`.

Let us try this in a synthetic example:

```{r}
# define objects of class parent and child, respectively.
P <- structure(numeric(), class = "parent_class")
C <- structure(numeric(), class = c("child_class", "parent_class"))

# now implement print, first for parent_class
print.parent_class <- function(x) {
  cat("this is print for parent_class objects")
}

print(P)
print(C)

# now implement print for child_class
print.child_class <- function(x) {
  cat("this is print for child_class objects")
}

print(P)
print(C)
```

It can be seen that when the first two print statements are called (before the print method for child class is implemented) both `C` and `P` are recognised as having the functionality of the parent class. But once the `print` function for the child class is available `C` is printed as a child_class object and `P` is printed as a parent class object.

We stop short of explaining more details of inheritance with S3 and refer to the additional documentation.


