---
title: Object-oriented programming
weight: 2
output:
  blogdown::html_page:
    toc: true
---

Under construction.

## Outlook

The purpose of this chapter is introducing you to object-oriented programming (OOP) in R. Base R offers three different models for OOP:

- [S3](http://search.r-project.org/library/base/html/UseMethod.html),
- [S4](http://search.r-project.org/library/methods/html/Introduction.html), and
- [Reference Classes](http://search.r-project.org/library/methods/html/refClass.html).

Further, some R packages on CRAN are available that provide additional models (e. g., R6, R.oo or proto).

Here we focus on an introduction of the models available in base R and a discussion of their advantages and disadvantages. For a more in depth introduction to the mechanics of OOP in R you may want to read in Part III of [Advanced R](https://adv-r.hadley.nz/oo.html).

## Terminology

An important reason to use OOP is that it allows for [**polymorphism**](https://en.wikipedia.org/wiki/Polymorphism_(computer_science)), which greatly fascilitates reusability and extendability. Polymorphism means that a single symbol may refer to different types. In particular, this approach allows for the separation of the interface of a piece of software and its implementation. A software developer who wants to reuse some already existing software thus only needs to know the interface against which he is programming and what the expected behaviour is. The details of the implementation on the other hand are not required to be know. One specific implementation of an interface could thus even be exchanged for another one and the two implementations may (internally) works quite different without affecting the validity of the software that makes use of them.

In OOP the implementation is **encapsulated** in an **object**; i. e., its data and functionality are conceptionally at the same place, but separate from the rest. Every object is typed and the details of the type are specified in its **class** definition. The state (this can include data) of an object is specified via its **fields** and the behaviour is specified by its **methods**. Many OOP model (but not all) allow for [**inheritance**](https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)) when defining new classes. If one class (the derived class is usually referred to as the child) inherits from another class (the base class is usually referred to as the parent) then the child class will have all the fields and methods of the parent class available and the fields and methods from the definition are added to those. The resulting hierarchical structure is often displayed graphically in form of a [class diagram](https://en.wikipedia.org/wiki/Class_diagram) which are part of the [Unified Modelling Language](https://en.wikipedia.org/wiki/Unified_Modeling_Language) (UML). The use of UML can be very helpful when designing software systems using OOP.

With classes and their relationships to each other laid out in a tactical way (e. g., via inheritance and how they interact or are associated to each other) software systems become more easily maintainable and it is often possible to extend functionality without changes to the already existing code. Reusable solutions and best practices in OOP are documented in a formalised fashion as [**design patterns**](https://en.wikipedia.org/wiki/Software_design_pattern).

The different OOP models in R vary in the degree of encapsulation that they provide. S3 is probably the least rigorous of the models available in base R. In [Advanced R](https://adv-r.hadley.nz/oo.html) it is described as **functional OOP**, because of the mechanism in which a function call of the form `generic(object, additional_args)` is dispatached. Here, a **method dispatach** refers to finding the right code to evaluate given the type of `object`. S4 enforces more disciplined programming by requiring formal definitions that S3 does not require. The upside to this extra work is that a greater degree of integrity can be guaranteed. Reference Classes implement properly encapsulated object-oriented paradigm. In particular, they are **mutable**, meaning that they can be modified in place avoiding R's usual copy-on-modify mechanism.

## S3

The easiest and most informal system for OOP in R is called S3 (named after version 3 of the S programming language into which it was introduced). For S3 there is no formal class definition. While, on the one hand, this makes using the system very flexible, on the other hand, it also means that there are usually no build-in integrity checks. Programming with S3 is largely based on conventions. We outline how to use S3 in the rest of this section.

An S3 object is an object of a base type with the attribute `class` set to the class name. If you feel that you need to revise what base types and attributes are in R we refer you to Sections [3.3](https://adv-r.hadley.nz/vectors-chap.html#attributes) and [12](https://adv-r.hadley.nz/vectors-chap.html#attributes) in [Advanced R](https://adv-r.hadley.nz/oo.html). The functions `class()` and `unclass()` provide a convenient way to set the attribute to a class name or strip it off the object again.

It is good practice to have a **constructor** function that a user can call to initialise all relevant elements of the object and then return the object afterwards. In [Advanced R](https://adv-r.hadley.nz/oo.html) it is recommended to have only the essential elements in the constructor and validate the arguments in a separate function (the **validator**). Further, in [Advanced R](https://adv-r.hadley.nz/oo.html) it is recommended to have a **helper** function that is intended for end users. This function is meant to make the constructor more user-friendly, for example, by anticipating common mistakes and correcting them on the fly.

The following code block illustrates how to construct a vector `y` with $n$ responses, an $n \times p$ design matrix `x` and the ordinary least squares estimate b into an S3 object.

```{r}
# set seed for reproducibility
set.seed(123)

# define sample size, coefficients, regressor and response
n  <- 50
b0 <- matrix(c(2, -1), ncol = 1)
x  <- rnorm(n)
y  <- b0[1] + b0[2] * x + rnorm(n)

# Constructor for `simple_lin_regression`.
#
# This function computes the ordinary least squares estimate
# for the simple linear regression E[y|x] = b0 + b1 * x.
#
# Params: y - a vector with n elements; observed responses
#         x - a vector with n elements; observed regressors
#
# Returns: an S3 object of type simple_lin_regression
#
simple_lin_regression <- function(y, x) {
  # define design matrix
  n <- length(y)
  D  <- matrix(c(rep(1, n), x), ncol = 2)
  
  # compute the OLS estimate
  b  <- solve(t(D) %*% D) %*% t(D) %*% y 
  
  # the object will encapsulate y, X and b
  slr <- list(response = y, regressor = x, estimate = b)
  
  # the object `slr` is declared to be an S3 object of
  # class "simple_lin_regression", by
  class(slr) <- "simple_lin_regression"
  
  return(slr)
}

sl1 <- simple_lin_regression(y, x)
```

One reason for organising the data and estimates in this way is that we can now implement special versions of generic methods (e. g., `print` and `plot`) that will be capable of working with this class of objects. Methods for S3 objects are defined by the following naming convenction `[method_name].[class_name]()`. For example, we can implement `print` and `plot` for our class `simple_lin_regression` by the following code

```{r}
print.simple_lin_regression <- function(x, ...) {
  cat("head(x) =", head(x$regressor), "\n")
  cat("head(y) =", head(x$response), "\n\n")
  cat("Estimated regression: E[y|x] = b0 + b1 * x\n")
  cat("b0 = ", x$estimate[1], " and b1 = ", x$estimate[2], ".\n", sep = "")
}

plot.simple_lin_regression <- function(x, y = NULL, ...) {
  plot(x = x$regressor, y = x$response,
       xlab = expression(X), ylab = expression(Y))
  abline(a = x$estimate[1], b = x$estimate[2])
}
```

Now we call them on the object `sl` that we previously created.
```{r}
print(sl1)
plot(sl1)
```

Note that to implement a method for an S3 class, a generic function of the same name needs to exist. You can, for example, see the definition of the generic function `plot` by
```{r}
plot
```

Note that the generic function `plot` has two compulsory arguments `x` and `y` and optional arguments indicated by `...`. The generic functions body is always a call of the function `UseMethod("[name_of_generic_function]")`.

When defining a method that implements a generic function for an S3 object it must have the same arguments as the generic function.

It is possible to introduce new generic functions. For example, we want to do a residual analysis. No generic `residual_analysis` does yet exist and we therefore define it ourselves:
```{r}
residual_analysis <- function(x) {
  UseMethod("residual_analysis")
}
```

Next we implement it for our `simple_lin_regression` class:

```{r}
residual_analysis.simple_lin_regression <- function(x) {
  predictions <- x$estimate[1] + x$estimate[2] * x$regressor
  plot(x = predictions, y = x$response - predictions,
       xlab = expression(hat(Y)), ylab = expression(Y - hat(Y)))
}
```

Now, we can apply the residual analysis function to our object:
```{r}
residual_analysis(sl1)
```

S3 classes allow for inheritance by setting the `class` attribute to a vector of class names.

For an example let us create an object of class `ordered` and check its class:
```{r}
ord_factor <- ordered(c("a", "b", "a"))
class(ord_factor)
```

You can see that the first element of the class attribute is `ordered` and the second is `factor`. This means that the class `ordered` extends the class factor. If a generic is implemented for the class ordered it will be called, but if it is not (yet) implemented the dispatch mechanism will try to find an implementation of the generic for class `factor`.

Let us try this in a synthetic example:

```{r}
# define objects of class parent and child, respectively.
P <- structure(numeric(), class = "parent_class")
C <- structure(numeric(), class = c("child_class", "parent_class"))

# now implement print, first for parent_class
print.parent_class <- function(x) {
  cat("this is print for parent_class objects")
}

print(P)
print(C)

# now implement print for child_class
print.child_class <- function(x) {
  cat("this is print for child_class objects")
}

print(P)
print(C)
```

It can be seen that when the first two print statements are called (before the print method for child class is implemented) both `C` and `P` are recognised as having the functionality of the parent class. But once the `print` function for the child class is available `C` is printed as a child_class object and `P` is printed as a parent class object.

We stop short of explaining more details of inheritance with S3 and refer to the additional documentation.


## S4

A more formal approach to OOP in R is implemented in S4 (named after version 4 of the S programming language into which it was introduced). In S4 all relevant elements as, for example, classes have to be defined explicitly. This is in sharp contrast of S3 which is largely based on conventions. While, on the one hand, this requires additional effort from the programmer, on the other hand, it can also aid to achieve more clarity and allows for build-in integrity checks. We outline how to use S4 in the rest of this section. Further information can be found in, for example, [the R documentation on S4](http://search.r-project.org/library/methods/html/Introduction.html) and [Section 15 of Advanced R](https://adv-r.hadley.nz/s4.html) (also see the "Learning More" section of it).

The R functions related to S4 are available in the `methods` package. This package is usually loaded by default. It is nevertheless, for example to indicate to someone reading the code later, advisable to load it before you start using S4:

```{r}
library(methods)
```

As mentioned before, S4 classes have to be declared formally. This is done by invoking the `setClass` function. As an example, we will now redo the simple linear regression example with S4:

```{r}
setClass("simple_lin_regression",
   slots = c(
     response  = "numeric",
     regressor = "numeric",
     estimate  = "numeric"
     )
)
```

In the call of `setClass` above, two arguments are provided. The first argument (it is named `Class`) is the name of the class that is being defined. The second argument is `slots` which is required to be a named character vector. Note that declaring an S4 class, where fields are declared by name and type, is more rigorous than declaring a class in S3 where any base typed object can be turned into an S3 object by adding the attribute `class` (with the name of the S3 class) to it.

An object from the class can then be instantiated by use of the function `new`. To avoid that an end-user needs to deal with the mechanics of S4 this call is usally wrapped in a constructor class (similar to what was also done in S3):

```{r}
# Constructor for `simple_lin_regression`.
#
# This function computes the ordinary least squares estimate
# for the simple linear regression E[y|x] = b0 + b1 * x.
#
# Params: y - a vector with n elements; observed responses
#         x - a vector with n elements; observed regressors
#
# Returns: an S4 object of type simple_lin_regression
simple_lin_regression <- function(y, x) {
  slr <- new("simple_lin_regression",
             response  = y,
             regressor = x
             )
  return(slr)
}
```

We could now call `simple_lin_regression(y, x)` and it would return an S4 object of class "simple_lin_regression" with the slots `response` and `regressor` set (try this!) but, as you might have noticed, computing the estimate has not yet been implemented and therefore this slot would be `numeric(0)`. Instead of implementing the computation of the least squares estimate in the constructor, we are going to use a special mechanism for initialisation that is provided by S4:

```{r}
setMethod("initialize", "simple_lin_regression",
  function(.Object, response, regressor) {
    .Object@response  <- response
    .Object@regressor <- regressor

    # define design matrix
    n <- length(response)
    D  <- matrix(c(rep(1, n), regressor), ncol = 2)

    # compute the OLS estimate
    b  <- solve(t(D) %*% D) %*% t(D) %*% response
    .Object@estimate <- as.numeric(b)
    return(.Object)
  }
)
```

Explanation and some remarks regarding the above definition of `initialize` for objects of class `simple_lin_regression` are in order now. We first describe the code line by line.

The first two arguments to `setMethod` are the name of the generic function that we are implementing (here: `initialize`) and the signature, i. e., the classes that some of the arguments of this function have to have for this particular implementation of the function to be invoked. `initialize` is a non-standard generic function that is called within the function `new` and by default (does some checks and then) sets the slots to the values provided as the arguments to `new`.

Our implementation above will be called if the first argument `.Object`, this is the class of the object created by `new`, is of class "simple_lin_regression". Further (cf. the second line of the call of `setMethod` above), we now require that only two additional arguments are provided in the call of `new("simple_lin_regression", ...)`: these arguments must be called `response` and `regressor` and no other argument (in particular, no `estimate`) must be given. You may want to take a look at the definitions of the generic function `initialize` and the function `new`.

In lines 3 and 4 of the code above we then set the values of slots `response` and `regressor` to the values that are passed to the call of `new`. Note that slots of an object can be accessed via the `@` operator. To achieve proper encapsulation, the `@` operator should only be used within method definitions, but never from outside. To allow end-users to access the value of slots, one should instead provide getter and setter methods (more on that later).

In lines 5-11 we compute the least squares estimate and in line 12 we assign the estimate to the slot `estimate`. An important observation to be made in line 12 is that the value of the variable `b` has to be cast from being a `matrix` to being a `numeric`. This is important, because the slots are all typed and assigning a matrix to a numeric without casting it before would cause an error to be thrown (try that this indeed happens).

In the last line of the definition of the new `initialize` method we return the object with all its slots initialised with the correct values.

**Note**: Implementing an `initialize` method for a class also provides for a convenient and reliable way to set default values to each slot. Another way to set default values is by setting the `prototype` argument of `setClass`, but the R documentation of `setClass` contains a remark that discourages users to do so and implement the `initialize` method instead.


With the specialised implementation of `initialize` in place we could now call `simple_lin_regression(y, x)` and will see that it returns an object with all slots properly populated (try that). But, before we actually call it we will also implement the `print` and `plot` method for the "simple_lin_regression" S4 class. Not that this is similar to the implementation of `initialize`, but possibly a bit easier:

```{r}
setMethod("print", "simple_lin_regression",
  function(x, ...) {
    cat("head(x) =", head(x@regressor), "\n")
    cat("head(y) =", head(x@response), "\n\n")
    cat("Estimated regression: E[y|x] = b0 + b1 * x\n")
    cat("b0 = ", x@estimate[1], " and b1 = ", x@estimate[2], ".\n", sep = "")
  }
)

setMethod("plot", "simple_lin_regression",
  function(x, y = NULL, ...) {
    plot(x = x@regressor, y = x@response,
         xlab = expression(X), ylab = expression(Y))
    abline(a = x@estimate[1], b = x@estimate[2])
  }
)
```

In the above implementation of the generic functions `print` and `plot` for the signature "simple_lin_regression" note that the code is almost exactly the same as the code that we used when implementing the S3 methods, but that in S4 we use the `@` operator to access the slots while in S3 we used `$`, because we were accessing named list elements (recall that the base type of our S3 implementation was `list()`). 

Now we can finally call the constructor to create the object and may use the designated `print` and `plot` method to handle it.

```{r}
slm1 <- simple_lin_regression(y, x)
print(slm1)
plot(slm1)
```

Next, we implement an S4 version of `residual_analysis` that we had also discussed in the chapter on S3:
```{r}
setGeneric("residual_analysis")

setMethod("residual_analysis", "simple_lin_regression",
  function(x) {
    predictions <- x@estimate[1] + x@estimate[2] * x@regressor
    plot(x = predictions, y = x@response - predictions,
         xlab = expression(hat(Y)), ylab = expression(Y - hat(Y)))
  }
)

residual_analysis(slm1)
```

Here we have used `setGeneric` to make the `residual_analysis` generic function available and then `setMethod` to implement it for objects of class `simple_lin_regression`. Not that we have again used the `@` operator in the implementation.

Next, we will add getter and setter methods that were mentioned before. Getter and setter methods should be provided to end users when they are meant to read and write the values of slots. First we do this for the `response` slot:

```{r}
setGeneric("response", function(x) standardGeneric("response"))
setGeneric("response<-", function(x, value) standardGeneric("response<-"))

setMethod("response", "simple_lin_regression", function(x) x@response)
setMethod("response<-", "simple_lin_regression",
  function(x, value) {
    x@response <- value
    x <- initialize(x, response = value, regressor = x@regressor)
    validObject(x)
    return(x)
  }
)
```

Note that the setter function calls the `initialize` function again before returning the updated object.
Further, the method `validObject` is called before the modified object is returned. Calling `validObject(x)` tests if the S4 object `x` is formally valid. Having such a function in place is one of the build-in mechanisms that ensures integrity. We comment a bit more on it in one of the next paragraphs.
Now, we can use this function to retrieve or modify the value of the `response` slot in the object. The following code prints the summary of the object `slm1`, then changes the value of the first observation of the `response` by adding 20 (making this observation an outlier), then print the summary of the updated object `slm1`:

```{r}
print(slm1)
response(slm1)[1] <- response(slm1)[1] + 20
print(slm1)
```

Note that we have changed the value of the `response` slot, but the `estimate` slot was updated as well (without the end user having to do anything to make this happen).

Now we come back to the mechanism to check validity of an object. Besides the standard checks, it is possible to add further checks. For example, we might want to ensure that `response` and `regressor` are always vectors of the same length. Note that we don't need to make sure that it is numerical vectors, because this is already ensured by the default mechanism, as the following code illustrates:

```{r}
#>  response(slm1) <- "this shouldn't be text!"

##  Error in (function (cl, name, valueClass)  :
##    assignment of an object of class “character” is not valid for @‘response’
##    in an object of class “simple_linear_regression”; is(value, #"numeric")
##    is not TRUE
```

Next we are going to implement a validitor for our class, using the `setValidity` method:
```{r}
setValidity("simple_lin_regression",
            function(object) {
              if(length(object@response) == length(object@regressor)) TRUE
              else paste("Unequal lengths of regressor and response.")
            })

```

Now, if we try to set the `response` slot to a numerical vector of length different to `n` we will see an error specific to the violation of our condition:
```{r}
#>  response(slm1) <- response(slm1)[1:49]

## Error in validObject(x) :
##   invalid class “simple_lin_regression” object: Unequal lengths of regressor
##   and response.
```

Similarly to the `response` slot, we now define getter and setter methods for the `regressor` slot.
Further, for the `estimate` slot we define a getter method. We do not define a setter method for the `estimate` slot, because end users are not supposed to change the values of `estimate`. The `estimate` is computed automatically and always corresponds to `response` and `regressor`.

```{r}
setGeneric("regressor", function(x) standardGeneric("regressor"))
setGeneric("regressor<-", function(x, value) standardGeneric("regressor<-"))

setMethod("regressor", "simple_lin_regression", function(x) x@regressor)
setMethod("regressor<-", "simple_lin_regression",
  function(x, value) {
    x@regressor <- value
    x <- initialize(x, response = x@response, regressor = value)
    validObject(x)
    return(x)
  }
)

setGeneric("estimate", function(x) standardGeneric("estimate"))
setMethod("estimate", "simple_lin_regression", function(x) x@estimate)
```

Next, we test the getter and setter for the `regressor` slot as before, but we use the getter for the `estimate` slot instead of the `print` method:
```{r}
estimate(slm1)
regressor(slm1)[1] <- regressor(slm1)[1] + 20
estimate(slm1)
```

The residual plot nicely shows the outlier that we have introduced:
```{r}
residual_analysis(slm1)
```

We are now going to (very briefly) discuss how [relationships between objects](https://en.wikipedia.org/wiki/Class_diagram#Relationships) can be modelled with S4. For a more depth discussion on this topic, please refer to the recommended literature.

When individual objects are related to one another this can be called an [instance-level relationship](https://en.wikipedia.org/wiki/Class_diagram#Instance-level_relationships). To model this kind of relationship a slot is added to the two classes of which individual objects will be related and the type of the slot will be the class of the related object.

When all objects of one class are related to all objects of another class in the way that one is a more general version of the other then we model [inheritance](https://en.wikipedia.org/wiki/Class_diagram#Generalization/Inheritance). In S4 a class is modelled to inherit from another class by adding the `contains` argument to the call of `setClass`. If a child class inherits from a parent class this implies that the child will have all slots available that are available to the parent. S4 allows for multiple inheritance such that a vector of classes to inherit from can be provided. In this case a child has all slots of all its parents available.

The inheritance relationships also determine the behaviour of the object; i. e., which methods are associated with a class. The method dispatch (the process of determining which implementation of a generic is called) with S4 can become quite complicated when multiple inheritance or multiple arguments are present. But, if there is only one argument and no multiple inheritance it is quite straight forward to see which method is called: it is first tested whether the method is implemented for the classes of the argument and if not the parent is tested, then the "grand parent", etc. You may want to refer to `?Methods_Details` or [Section 15.5 in Advanced R](https://adv-r.hadley.nz/s4.html#s4-dispatch) for details on the method dispatch in more difficult cases.
